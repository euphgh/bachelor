\chapter{技术背景及研究动机}

\section{RISC-V虚拟化扩展}
RISC-V的虚拟化扩展需要添加的硬件功能大致可分为特权控制和虚拟内存两大部分。
在特权控制方面，主要新增了3种特权模式、12条特权指令、23个控制状态寄存器以及虚拟化相关的4种中断和6种异常。
在虚拟内存方面，首先定义了第二阶段地址翻译的概念，
同时添加了上述部分的控制状态寄存器、虚拟内存管理指令和异常，为程序员提供了管理第二阶段地址翻译的手段。

\paragraph{特权控制}
特权等级在未支持虚拟化扩展时只有机器模式（M-mode）、监管模式（S-mode）和用户模式（U-mode）。
分别对应标准体系结构中运行引导程序，操作系统和用户程序的机器状态。
虚拟化扩展下的特权等级变化如图\ref*{fig:priv-mode}，原本的监管模式被改成虚拟机管理模式（HS-mode），对应于虚拟机管理程序的层级。
还新增了虚拟监管模式（VS-mode）和虚拟用户模式（VU-mode），对应于虚拟机和虚拟机下的用户态程序。
此外还保留了原始的用户模式，对应于Type2虚拟机监管系统下的宿主操作系统的用户程序。
例如在Linux KVM中，需要先启动宿主Linux操作系统，此时处理器运行在虚拟机管理模式下。
在宿主操作系统除了具有启动虚拟机的功能，还具有一般Linux操作系统的所有能力。
在未启动虚拟机时运行的用户态程序时，处理器就在用户模式下，而不是虚拟用户模式。

\begin{figure}[htbp]
    \centering
    \includegraphics{priv-mode.png}
    \caption{RISC-V虚拟化扩展特权等级变化}
    \label{fig:priv-mode}
\end{figure}

控制管理寄存器（Control Status Register，CSR）是RISC-V处理器中的一组特殊寄存器，
用于控制处理器的行为和存储处理器的状态信息。
这些寄存器包含了处理器的核心控制逻辑和状态信息，可以被软件访问和操作。
虚拟化扩展下，控制管理寄存器的一个最主要的变化是添加了一套在虚拟监管模式下使用的，
用于处理虚拟机中的异常自陷的流程的寄存器，例如配置自陷地址的vstvec、保存异常指令地址的vsepc。
分离管理系统和虚拟机中使用的配置寄存器，能够使得虚拟机中出现异常时可以自己处理，不必自陷到虚拟机管理系统中。
另一个变化是添加了一些虚拟机管理系统使用寄存器，用于配置管理系统可以捕获的虚拟机内执行的特殊指令（hstatus），
虚拟机的中断注入和委托（hedeleg、hideleg、hgeip、hgeie）等。 因此，在中断异常的种类方面，原始的监管模式下所有的中断被虚拟机管理模式和虚拟监管模式各复制一份，
虚拟机管理模式还需要添加一个虚拟机外部中断，用于实现虚拟机直通中断。

最后一部分是虚拟机管理模式下的特权指令和新增的页错误异常，为程序员提供管理虚拟地址翻译的方法。
在未实现虚拟化扩展下的SFENCE.VMA指令用于同步页表数据结构，相对的，虚拟化扩展下新增了HFENCE.VVMA和HFENCE.GVMA，
用于第二阶段地址翻译的页表数据结构的同步。
同时新增了HLV.width, HLVX.HU/WU, HSV.width指令，为虚拟机管理系统提供了读取虚拟机内存的方法。

\paragraph{虚拟内存}
第二阶段地址翻译是虚拟化扩展提出的重要概念，是指在虚拟化环境中进行的地址转换过程的第二个阶段。
在传统的虚拟地址翻译机制中，虚拟地址（Virtual Address）只需要经过一次多级页表翻译
即可成为物理地址（Physical Address）访问实际的内存。
在第二段地址翻译开启时，虚拟机操作系统会对内部的虚拟地址进行一次页表翻译，
即将虚拟机虚拟地址（Guest Virtual Address，GVA）翻译成虚拟机物理地址（Guest Physical Address，GPA）。
此时处理器还需要再进行一次多级地址翻译
将虚拟机物理地址翻译成主机物理地址（Host Physical Address，HPA）才能够访问内存。
图\ref*{fig:Sv39x4}以经典的三级页表——Sv39为例，展示了两者的关系。
未开启第二阶段翻译时，例如虚拟机管理程序运行时，
最多需要访问内存三次，获取三个页表项（Page Table Entry）即可完成地址翻译。
但在开启第二阶段地址翻译后，例如在虚拟监管模式下运行虚拟机，
每次访存获取下一级页表之前，都需要再经过三级页表翻译。
换言之，为了获得虚拟机的虚地址所对应的物理地址，最多需要12次的内存访问。

\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.8]{Sv39x4.png}
    \caption{RISC-V虚拟化扩展的两阶段地址翻译}
    \label{fig:Sv39x4}
\end{figure}

为了管理第二阶段的地址翻译的相关信息，处理器需要提供相应的指令和控制状态寄存器用于配置。
关于控制状态寄存器，首先是第二阶段地址翻译的叶目录的根地址，保存在hgapt的寄存器中，对应于保存第一阶段地址翻译相关信息的sapt寄存器。
其次，在地址翻译的过程中不免要进行访存和权限检查，如果失败会导致处理器产生一个页错误的异常，用于操作系统进行替换或者进一步的诊断。
因此，虚拟化扩展新增了虚拟机物理页错误的异常，对应于第二阶段地址翻译时的权限检查失败或者访存错误。
自然的，虚拟机物理页错误异常的处理程序需要触发异常的虚拟机物理地址进行诊断，htval和mtval2寄存器被新增用于在异常触发时保存虚拟机物理地址。
可以预见，处理器的流水线内部同样需要空间保存错误地址。
特别对于取指时触发的虚拟机页错误异常，需要该指令携带地址直至退休，这对流水线中的存储部件来说是一种较大的面积开销。
对于虚拟内存管理指令，在上文也有提及。用于同步第二阶段页表翻译单元数据结构的HFENCE.VVMA和HFENCE.GVMA指令。
一个简单的实现可以是无效处理器内有关第二阶段地址翻译的所有缓冲。
关于HLV.width, HLVX.HU/WU, HSV.width指令，实质是在虚拟机管理模式下开启第二阶段地址翻译进行访存。

\section{虚拟化扩展的软硬件支持}
在虚拟化拓展规范的仍处于草案阶段时，一些主流虚拟机管理程序和模拟器就已经随着拓展的技术规范的更新进行适配，
例如Xvisor\cite{micro2022xiangshan}、KVM\cite{kvm:H-ext}
QEMU\cite{qemu-riscv:H-ext}，Spike\cite{github:spike}等。
然而，关于虚拟化扩展的硬件实现，仅从拓展的0.6.1版本发布后才陆续出现。

虚拟化扩展的硬件实现工作最早开展在Rocket Chip\cite{itco2022rocket}中，这是加州大学伯克利分校开发的顺序单发射流水线处理器。
此外，该工作还在处理器中移植了Bao，一种轻量级的hypervisor\cite{ng-res2020bao}，并且进行了一些简易的虚拟化性能评测。
2023年，一个六级流水的乱序单发射开源处理器核心CVA6\cite{tvlsi2023cva6}也实现了虚拟化扩展。
该工作不仅进行了关于两阶段地址转化技术的微架构探索，还对性能、功耗、面积等物理设计进行了一系列优化。

在商业界，StarFive发布了Dubhe系列，这是首款支持虚拟化的商业级RISC-V处理器IP核。
此外，SiFive的P600系列处理器也支持虚拟化扩展。
其他支持虚拟化扩展的处理器包括InCore Semiconductors的Chromite处理器和IIT Madras发布的Shakti处理器。
这些处理器提供了硬件级别的支持，使得虚拟化技术在RISC-V体系结构中得到了广泛应用。

\section{“香山”处理器的内存管理单元}
未实现虚拟化扩展的“香山”处理器的内存管理单元的整体结构如图\ref*{fig:origin-mmu}所示，可分为如下两部分：
分布式的一级页表缓冲（Level 1 Translation Lookaside Buffer，L1TLB）和
集中式的二级页表缓冲（Level 2 Translation Lookaside Buffer，L2TLB）。

\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.6]{origin-mmu.png}
    \caption{“香山”处理器原始内存管理单元架构}
    \label{fig:origin-mmu}
\end{figure}

\paragraph{一级页表缓冲} 一级页表缓冲分布在处理器各个需要地址翻译的流水线中，例如前端的指令缓冲、指令预取，后端的访存流水线。
一级页表缓存的缓存条目记录虚地址对应的多级页表翻译后的最终物理地址，因此可以实现地址翻译请求的快速的回应。
缓存条目的组织方式是全相连映射，同时每个缓存条目由使用直接映射的组织方式，存储了多个翻译结果。

\paragraph{二级页表缓冲} 当一级页表缓冲不命中时，会发送翻译请求到二级页表缓冲。
二级页表缓冲包括一个大型的页表缓冲（Page Cache）和硬件的页表翻译单元（Page Table Walker）。
页表缓冲的每个条目记录了虚地址对应的各级页表，可支持各级的地址翻译请求，具体而言，包括4KB、2MB、1GB三种大小的页表。
当翻译请求无法在页表缓存中找到，翻译请求会发送至页表翻译单元。翻译单元按照页表级数依次向页表缓冲发起查询请求，如果不存在，才会访问内存。
简而言之，页表缓存既负责L1TLB不命中时的三级页表翻译，同时也负责页表翻译单元在访问内存前的后备缓存。
当页表翻译单元访问内存结束后，会将翻译结果回填至页表缓冲。

\section{处理器设计的调试及评测平台}
在传统的处理器设计流程中，常用的平台包括硬件描述语言（Hardware Description Language，HDL）建模、
逻辑分析仪（Logic Analyzer）、软件仿真工具（Simulation Tools）
和现场可编程逻辑门阵列（Field-Programmable Gate Array，FPGA）。
然而，这些方法存在一些局限性，导致开发效率较低。

在调试方面，逻辑分析仪的软件仿真可以帮助观测硬件设计在外界激励下的行为。
通过数学模型和计算机算法模拟硬件设计，获取设计中各个信号值随时间的变化曲线，即波形图。
尽管波形图和仿真软件可以帮助工程师了解电路内部的所有状态，是错误调试的基础，
但是当需要在各种复杂场景下进行调试时，仍旧存在许多缺陷。
首先，波形重放在发现错误信号的能力有限。
单一信号的微小错误会被淹没在巨大的细节中，很可能数千万个周期后的才会暴露。
因此，学术界近年来提出了使用架构模拟器和差分测试的方法\cite{micro2022xiangshan}。
通过比对正确的体系结构信息，精确定位出错现场。
其次，仿真工具由于其可并行性低、同步要求高等自身特性，必然导致了执行速度原低于FPGA。
尽管在开源社区和学术界存在许多高效的解决方案，
例如verilator\cite{github:verilator}和manticore\cite{asplso23manticore}。
但在运行大型基准测试和系统软件时，花费的时间仍然不可接受。

在评测方面，FPGA被广泛运用于原型验证。
通过将处理器设计部署在物理的逻辑门和寄存器中，
FPGA能够提供更真实的测试环境和远快于软件仿真的运行速度。
同时，在FPGA中实现特定硬件的时间成本开销远小于通过流片方式生产的开销。
但是，FPGA由于其硬件特性，能够获取的波形信号和时间范围十分受限。
只能通过对外部设备的输出，判断硬件设计是否存在错误，无法提供调试所需的电路内部信息。
基于上述缺陷，学术界提出了一种通过FPGA加速软件仿真的方案——REMU\cite{iccd2023remu}，
通过将FPGA某一运行时刻的所有寄存器和存储器信息，精确重放到仿真软件中。
利用仿真软件生成波形的能力来帮助调试。
本项目中也使用了该方法发现硬件设计的错误，提高了开发效率。
